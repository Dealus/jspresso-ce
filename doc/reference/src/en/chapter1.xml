<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter>
  <title>Getting started</title>

  <para>This chapter will help you to understand the basics of the
  <trademark>D2S</trademark> application framework and how to work with
  it.</para>

  <section>
    <title>The human resources (HR) sample application</title>

    <para>The human resources application is a simple yet comprehensive
    business application targeted at managing a company organization and the
    employees who work in it. It will demonstrate how
    <trademark>D2S</trademark> can handle a domain model with its
    relationships and its constraints, present it to the end-user for
    manipulation through various built-in views and actions, handle security
    through profile management, distribute the frontend across the network,
    ...</para>

    <section>
      <title>The domain model</title>

      <para>To quickly introduce the HR domain model, let's dive into the
      following UML class diagrams. As a general rule to make the diagrams
      more readable attributes must in fact be considered as getter / setter
      pairs.</para>

      <para>The <link linkend="commons-cd">commons class diagram</link>
      describes commonly used interfaces and classes.</para>

      <para>A few hints :</para>

      <itemizedlist>
        <listitem>
          <para>The traceable interface is implemented by entities for which
          we need to record when it was saved for the first time and when it
          was last updated. Of course, these tracing elements must be made
          read-only to the end-user since they are automatically managed by
          the application.</para>
        </listitem>

        <listitem>
          <para>The nameable is implemented by entities having a name. A name
          has a max length of 64 characters and is mandatory.</para>
        </listitem>

        <listitem>
          <para>The contact information component is used by entities that
          have contact details (address, phone, email, ...). A contact
          information points to one and only one city. A city is nameable and
          has a zip code of maximum length 10 characters.</para>
        </listitem>

        <listitem>
          <para>An event is a piece of text which is traceable</para>
        </listitem>
      </itemizedlist>

      <figure id="commons-cd">
        <title>Commons class diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="60%"
                       fileref="../images/commons-cd.png" scalefit="1"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <link linkend="employee-cd">employees class diagram</link>
      describes what an employee is.</para>

      <para>A few hints :</para>

      <itemizedlist>
        <listitem>
          <para>An employee is nameable and traceable. An employee has
          :</para>

          <itemizedlist>
            <listitem>
              <para>a first name (his last name is inherited by the nameable
              interface)</para>
            </listitem>

            <listitem>
              <para>a social security number which is composed by exactly 10
              digits</para>
            </listitem>

            <listitem>
              <para>a gender (male or female)</para>
            </listitem>

            <listitem>
              <para>a birth date</para>
            </listitem>

            <listitem>
              <para>a hire date in the company</para>
            </listitem>

            <listitem>
              <para>a contact information</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>An employee must provide a method to compute his age based on
          his birth date.</para>
        </listitem>

        <listitem>
          <para>An employee has an ordered list of events.</para>
        </listitem>
      </itemizedlist>

      <figure id="employee-cd">
        <title>Employees class diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="60%"
                       fileref="../images/employees-cd.png" scalefit="1"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <link linkend="organization-cd">organization class
      diagram</link> describes how the company is structured in departments
      and teams.</para>

      <para>A few hints :</para>

      <itemizedlist>
        <listitem>
          <para>A company is structured in organizational units. An
          organizational unit may be a department or a team. An organizational
          unit has an identifier (<emphasis>ouId</emphasis>) which is formed
          by a 2 letter code followed by a dash followed by a 3 digit number
          (<emphasis>IS-001</emphasis> for instance). Each organizational unit
          has a manager who is an employee of the company it belongs to. An
          employee can at most manage one organizational unit. An
          organizational unit is nameable, traceable and has contact
          information as well as a company has.</para>
        </listitem>

        <listitem>
          <para>The company may have one or more departments and a department
          belongs to one and only one company.</para>
        </listitem>

        <listitem>
          <para>A department may have one or more teams and a team belongs to
          one and only one department. Each team is composed by one or more
          employees.</para>
        </listitem>

        <listitem>
          <para>An employee belongs to one and only one company. An employee
          may belong to zero or more teams.</para>
        </listitem>
      </itemizedlist>

      <figure id="organization-cd">
        <title>Organization class diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="60%"
                       fileref="../images/organization-cd.png" scalefit="1"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>The application modules</title>

      <para>The HR application is divided in 3 modules.</para>

      <section>
        <title>The organization management module</title>

        <para>This module manages a company structure in terms of
        organizational units. The end-user may create/delete/update a company,
        create/delete/update its organizational units and structure them in
        the organization. The end-user may compose the employee teams, assign
        an organisational unit manager but won't be able to
        create/update/delete an employee. The organization must be displayed
        in a hierarchical (tree) view.</para>
      </section>

      <section>
        <title>The employees management module</title>

        <para>This module manages a company staff. The end-user can retrieve
        the company employees and create/update/delete an employee. The
        end-user will be able to create/update/delete events for an employee
        and may re-order them in an unspecified manner as needed.</para>
      </section>

      <section>
        <title>The master data management module</title>

        <para>This module manages the application master data. As of now, the
        master data are only made of the cities available to compose the
        addresses.</para>
      </section>
    </section>

    <section>
      <title>The profiles</title>

      <para>The HR application offers 3 profiles.</para>

      <section>
        <title>The organization manager profile</title>

        <para>A logged-in user having the organization manager profile will be
        granted access to the organization management module as well as the
        master data management module but he won't be able to create a new
        company.</para>
      </section>

      <section>
        <title>The staff manager profile</title>

        <para>A logged-in user having the staff manager profile will be
        granted access to the employee management module as well as the master
        data management module but he won't be able to re-order the events
        assigned to an employee.</para>
      </section>

      <section>
        <title>The administrator profile</title>

        <para>The administrator profile has no restriction in the
        application.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Layering the application</title>

    <para>Now that we have collected the detailed specifications, it's time to
    feed the framework with them. As we saw before, most of the job will
    consist of describing the different layers in a structured way. But before
    going further, let's define the best practices regarding the logical
    layering of a typical <trademark>D2S</trademark> application (although
    these practices may generally apply to any well designed application). We
    will define 3 logical layers from the bottom to the top :</para>

    <itemizedlist>
      <listitem>
        <para>The domain model</para>
      </listitem>

      <listitem>
        <para>The backend</para>
      </listitem>

      <listitem>
        <para>The frontend</para>
      </listitem>
    </itemizedlist>

    <para>This organisation will help to prevent cyclic dependencies between
    layers since each layer will be allowed to use lower ones but not higher
    ones (e.g. : the backend may use the domain model but not the
    frontend).</para>

    <para>Of course, this is a minimal logical layering. Each of this layer
    may be further divided in subparts depending on the software complexity.
    For instance the domain model might be divided in master and movement data
    and the backend and frontend may be divided in modules. It's entirely up
    to the application designer to tailor these rules. But it surely is the
    first design activity.</para>

    <para>The <link linkend="general-cod">general architecture diagram</link>
    introduces this layering strategy.</para>

    <figure id="general-cod">
      <title>General architecture diagram</title>

      <mediaobject>
        <imageobject>
          <imagedata contentdepth="60%" fileref="../images/general-cod.png"
                     scalefit="1" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Let's define now what precisely go in these layers.</para>

    <section>
      <title>The domain model</title>

      <para>The domain model includes :</para>

      <itemizedlist>
        <listitem>
          <para>The entities. An entity will be described by :</para>

          <itemizedlist>
            <listitem>
              <para>properties along with their constraints and their
              interceptors</para>
            </listitem>

            <listitem>
              <para>behaviour (business methods, life-cycle
              interceptors)</para>
            </listitem>

            <listitem>
              <para>integrity enforcements</para>
            </listitem>

            <listitem>
              <para>default presentation elements (name, icon, rendered
              properties, ordering properties)</para>
            </listitem>

            <listitem>
              <para>relationships to other entities (cardinality,
              reversibility)</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The components. A component has all the characteristics of an
          entity except that it is not autonomous since It is designed as a
          structure to be inlined in an entity (e.g. : an address
          structure).</para>
        </listitem>

        <listitem>
          <para>Other structural elements like common business
          interfaces.</para>
        </listitem>
      </itemizedlist>

      <para>We will see later that there virtually any domain model can be
      extensively described using <trademark>D2S</trademark>. This includes
      for instance polymorphic entities or associations, multiple inheritance,
      ...</para>
    </section>

    <section>
      <title>The backend</title>

      <para>The backend includes all the application parts that do not depend
      on the client :</para>

      <itemizedlist>
        <listitem>
          <para>The actions server parts (which interact with the domain model
          for instance)</para>
        </listitem>

        <listitem>
          <para>The application modules along with their hierarchies of
          sub-modules. A module is a top application entry point which is
          directly accessible by the end user.</para>
        </listitem>

        <listitem>
          <para>The application sub-modules. They form a hierarchy since
          sub-modules may contain other sub-modules. Each sub-module is an
          independent application part targeted at accessing the backend data
          (domain model manipulation, reporting, ...).</para>
        </listitem>

        <listitem>
          <para>The backend controller which holds the user backend
          application state and its configuration (application modules
          registration)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>The frontend</title>

      <para>The frontend includes all the application parts that interact
      directly with the end-user :</para>

      <itemizedlist>
        <listitem>
          <para>The views</para>
        </listitem>

        <listitem>
          <para>The action client parts (which handle user interaction and
          trigger action server parts)</para>
        </listitem>

        <listitem>
          <para>The client application module parts</para>
        </listitem>

        <listitem>
          <para>The frontend controller which holds the user frontend
          application state and its configuration (client application modules
          registration)</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Describing the domain model</title>

    <para>In this chapter, you will learn how to feed the
    <trademark>D2S</trademark> framework with the hr sample domain model
    description.</para>

    <section>
      <title>Using the Spring dependency injection container</title>

      <para>Let's go back to the HR sample application. As for every layer
      introduced above, describing the domain model will consist in assembling
      <trademark>D2S</trademark> description java beans using the <ulink
      url="http://www.springframework.org/">Spring framework Dependency
      Injection Container</ulink>. To achieve this, you will have to write an
      XML file that conforms to the <ulink
      url="http://www.springframework.org/schema/beans/spring-beans-2.0.xsd">spring
      beans schema</ulink>. Of course, you can use any text editor but we will
      encourage you to use at least a schema-aware XML editor like <ulink
      url="http://www.jedit.org/">jEdit</ulink> or even better, use <ulink
      url="http://www.eclipse.org/">Eclipse</ulink> and <ulink
      url="http://springide.org/project/wiki/SpringideInstall">Spring
      IDE</ulink>. The latest will offer a lot of productivity enhancement
      with code completion for the XML elements and attributes as well as for
      the description bean class names and properties of
      <trademark>D2S</trademark>.</para>

      <para id="chapter1">The various description java beans that are provided
      by <trademark>D2S</trademark> are detailed in the next chapter.</para>

      <para>We will use the root package
      <code>com.d2s.framework.hrsample</code> for our application. The domain
      model description will logically go to the
      <code>com.d2s.framework.hrsample.model</code> package. In this package,
      we will create a <filename>hrsample-model.xml</filename> file as
      described below :</para>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans
  xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
                      http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
  default-lazy-init="true"&gt;

&lt;/beans&gt;</programlisting>
    </section>

    <section>
      <title>Describing the first components</title>

      <para>As a starting point, we will describe the <link
      linkend="commons-cd">commons</link> model part.</para>

      <para>The <code>Nameable</code> interface may be described as follow
      :</para>

      <programlisting language="xml">&lt;bean <co id="n-bean" />
  id="Nameable" <co id="n-id" />
  class="com.d2s.framework.model.descriptor.basic.BasicInterfaceDescriptor"&gt; <co
          id="n-class" />
  &lt;constructor-arg
    value="com.d2s.framework.hrsample.model.Nameable" /&gt; <co
          id="n-classname" />
  &lt;property name="propertyDescriptors"&gt; <co id="n-props" />
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;<co
          id="n-stringprop" />
        &lt;property
          name="name" <co id="n-name" />
          value="name" /&gt;
        &lt;property
          name="maxLength" <co id="n-maxl" />
          value="64" /&gt;
        &lt;property
          name="mandatory" <co id="n-mand" />
          value="true" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <calloutlist>
        <callout arearefs="n-bean">
          <para>This is a standard spring bean definition. We are creating a
          descriptor bean.</para>
        </callout>

        <callout arearefs="n-id">
          <para>The identifier of this descriptor bean instance for later
          reference.</para>
        </callout>

        <callout arearefs="n-class">
          <para>Since we are describing a generic interface (which may or may
          not turn to be an entity) we will use a
          <code>BasicInterfaceDescriptor</code> as opposed to a
          <code>BasicEntityDescriptor</code>.</para>
        </callout>

        <callout arearefs="n-classname">
          <para>The (fully-qualified) name of this interface.</para>
        </callout>

        <callout arearefs="n-props">
          <para>The property descriptors of this interface descriptor.</para>
        </callout>

        <callout arearefs="n-stringprop">
          <para>The string property descriptor to hold the <code>name</code>
          property description.</para>
        </callout>

        <callout arearefs="n-name">
          <para>The name of the <code>name</code> property which is
          "name".</para>
        </callout>

        <callout arearefs="n-maxl">
          <para>The maximum length of the name property which is 64
          characters.</para>
        </callout>

        <callout arearefs="n-mand">
          <para>The fact that the <code>name</code> property is mandatory on a
          <code>Nameable</code>.</para>
        </callout>
      </calloutlist>

      <para>As you can see above, we create an interface descriptor
      (<code>com.d2s.framework.sample.backend.domain.Nameable</code>) with one
      property (<code>name</code>) along with its constraints
      (<code>maxLength</code> and <code>mandatory</code>). This is a fairly
      simple interface since it has no intrinsic behaviour nor relationships
      with other components.</para>

      <para>So now, lets describe the <code>Traceable</code> interface as
      follow :</para>

      <programlisting language="xml">&lt;bean
  id="Traceable"
  class="com.d2s.framework.model.descriptor.basic.BasicInterfaceDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Traceable" /&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicDatePropertyDescriptor"&gt; <co
          id="t-createTimestamp" />
        &lt;property
          name="name"
          value="createTimestamp" /&gt;
        &lt;property
          name="type"
          ref="DATE_TIME" /&gt; <co id="t-DATE_TIME" />
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicDatePropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="lastUpdateTimestamp" /&gt;
        &lt;property
          name="type"
          ref="DATE_TIME" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="unclonedProperties"&gt; <co id="t-uncloned" />
    &lt;list&gt;
      &lt;value&gt;createTimestamp&lt;/value&gt;
      &lt;value&gt;lastUpdateTimestamp&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <calloutlist>
        <callout arearefs="t-createTimestamp">
          <para>The date property descriptor to hold the
          <code>createTimestamp</code> property. Same applies for the
          <code>lastUpdateTimestamp</code> property.</para>
        </callout>

        <callout arearefs="t-DATE_TIME">
          <para>We want to preserve date and time information in this property
          as opposed to only date information.</para>
        </callout>

        <callout arearefs="t-uncloned">
          <para>Whenever a <code>Traceable</code> component is duplicated, we
          want exclude the tracing values from the cloning process.</para>
        </callout>
      </calloutlist>

      <para>The <code>Traceable</code> interface description is slightly more
      complicated than the <code>Nameable</code> interface since not all
      properties are eligible to cloning
      (<code>unclonedProperties</code>).</para>
    </section>

    <section>
      <title>Generating the component classes</title>

      <para>It is time now to get our interfaces generated before going
      further. Let's use the <trademark>D2S</trademark> generation tool to
      make it happen. <trademark>D2S</trademark> provides a <ulink
      url="http://freemarker.org/">freemarker</ulink> template to generate the
      components that may be easily triggered using a simple ant task. Since
      this generator explores the spring beans definitions, we first need to
      declare our <code>hrsample-model.xml</code> as being part of our
      application. To achieve that, let's create a configuration file named
      <code>beanRefFactory.xml</code> in the root source folder (without any
      package) as follow :</para>

      <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans
  xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
                      http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
  default-lazy-init="true"&gt;

  &lt;bean
    id="hrsample-model-context"
    class="org.springframework.context.support.ClassPathXmlApplicationContext"
    lazy-init="true"&gt;
    &lt;constructor-arg&gt;
      &lt;list&gt;
        &lt;value&gt;com/d2s/framework/application/commons.xml&lt;/value&gt; <co
            id="brf-commons" />
        &lt;value&gt;com/d2s/framework/tools/entitygenerator/mock.xml&lt;/value&gt; <co
            id="brf-mock" />
        &lt;value&gt;com/d2s/framework/hrsample/model/hrsample-model.xml&lt;/value&gt; <co
            id="brf-model" />
      &lt;/list&gt;
    &lt;/constructor-arg&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</programlisting><calloutlist>
          <callout arearefs="brf-commons">
            <para>The commons bean definitions of the
            <trademark>D2S</trademark> framework.</para>
          </callout>

          <callout arearefs="brf-mock">
            <para>A configuration file to mock undefined (for the moment) bean
            references; this file is only used for the component generation
            phase.</para>
          </callout>

          <callout arearefs="brf-model">
            <para>Our application model description file.</para>
          </callout>
        </calloutlist>This configuration file assembles the necessary spring
      configuration files for the generator to operate. So we are ready to
      operate the generator using the following build.xml ant file :</para>

      <programlisting>&lt;?xml version="1.0"?&gt;

&lt;project default="all"&gt;

  &lt;property file="build.properties" /&gt;
  &lt;property name="xdoclet.lib.dir" value="${xdoclet.home}/lib" /&gt;
  &lt;property name="xdoclet.plugins.dir" value="${xdoclet.home}/plugins" /&gt;

  &lt;property name="src.dir" value="${basedir}/src/main" /&gt;
  &lt;property name="java.src.dir" value="${src.dir}/java" /&gt;
  &lt;property name="resources.src.dir" value="${src.dir}/resources" /&gt;
  &lt;property name="ddl.dir" value="${src.dir}/ddl" /&gt;

  &lt;path id="entity.generator.classpath"&gt;
    &lt;dirset dir="${basedir}"&gt;
      &lt;include name="**/target/classes" /&gt;
    &lt;/dirset&gt;
    &lt;fileset dir="${m2.repo}"&gt;
      &lt;include name="**/design2see/**/2.0/*.jar" /&gt;
      &lt;include name="**/commons-cli-1.0.jar" /&gt;
      &lt;include name="**/freemarker-2.3.3.jar" /&gt;
      &lt;include name="**/spring-2.0.6.jar" /&gt;
      &lt;include name="**/commons-logging-1.1.jar" /&gt;
      &lt;include name="**/xml-apis-2.0.2.jar" /&gt;
      &lt;include name="**/xerces-2.0.2.jar" /&gt;
      &lt;include name="**/bsf-2.3.0.jar" /&gt;
      &lt;include name="**/commons-beanutils-1.7.0.jar" /&gt;
    &lt;/fileset&gt;
  &lt;/path&gt;

  &lt;target name="generate-entities"&gt;
    &lt;java classname="com.d2s.framework.tools.entitygenerator.EntityGenerator"
          classpathref="entity.generator.classpath"&gt;
      &lt;arg value="-applicationContextKey" /&gt;
      &lt;arg value="hrsample-model-context" /&gt;
      &lt;arg value="-templateResourcePath" /&gt;
      &lt;arg value="/com/d2s/framework/tools/entitygenerator" /&gt;
      &lt;arg value="-templateName" /&gt;
      &lt;arg value="HibernateXdocletEntity.ftl" /&gt;
      &lt;arg value="-outputDir" /&gt;
      &lt;arg value="${java.src.dir}" /&gt;
      &lt;arg value="-includePackages" /&gt;
      &lt;arg value="com.d2s.framework.hrsample.model" /&gt;
    &lt;/java&gt;
  &lt;/target&gt;

  &lt;target name="all" depends="generate-entities" /&gt;

&lt;/project&gt;</programlisting>

      <para>You may now have a look into the
      <code>com.d2s.framework.hrsample.model</code> package source directory.
      You may find the 2 generated classes :</para>

      <itemizedlist>
        <listitem>
          <para><filename>Nameable.java</filename> for the Nameable interface
          (see the <link linkend="Nameable">source code below</link>).</para>
        </listitem>

        <listitem>
          <para><filename>Traceable.java</filename> for the Traceable
          interface.</para>
        </listitem>
      </itemizedlist>

      <programlisting id="Nameable" language="java">/*
 * Generated by Design2see. All rights reserved.
 */
package com.d2s.framework.hrsample.model;

/**
 * Nameable component.
 * &lt;p&gt;
 * Generated by Design2see. All rights reserved.
 * &lt;p&gt;
 *
 * @author Generated by Design2see
 * @version $LastChangedRevision$
 */
public interface Nameable {

  /**
   * Gets the name.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "NAME"
   *           length = "64"
   *           not-null = "true"
   * @return the name.
   */
  java.lang.String getName();

  /**
   * Sets the name.
   *
   * @param name
   *          the name to set.
   */
  void setName(java.lang.String name);

}</programlisting>

      <para>These 2 java classes are in fact interfaces with getters and
      setters for the declared properties. In fact, you will never need any
      implementation for them since <trademark>D2S</trademark> will
      automatically handle their implementation for you at runtime using
      proxies. So you might wonder why we still need those interfaces instead
      of completely relying on the descriptors ? This is to benefit from the
      strong compilation enforcements, code completion in IDE, ... Anything
      you will need for quality, robustness and productivity when you are
      manipulating your components.</para>

      <para>You may also notice that the generator took care of annotating the
      classes with <ulink url="http://www.hibernate.org/">hibernate</ulink>
      <ulink
      url="http://xdoclet.sourceforge.net/xdoclet/index.html">xDoclet</ulink>
      attributes. They will be used later to generate the necessary
      persistence meta-data.</para>
    </section>

    <section>
      <title>Adding life-cycle behaviour</title>

      <para>What about the handling of the <code>Traceable</code> properties ?
      We want them to follow the life-cycle of any traceable entity, i.e.
      :</para>

      <itemizedlist>
        <listitem>
          <para>Set the <code>createTimestamp</code> when the entity is
          persisted for the first time.</para>
        </listitem>

        <listitem>
          <para>Set the <code>lastUpdateTimestamp</code> when the entity is
          updated in the persistent store.</para>
        </listitem>
      </itemizedlist>

      <para>It is time to write our first lines of java to achieve that. So
      let's create the life-cycle interceptor
      <code>com.d2s.framework.hrsample.model.service.TraceableLifecycleInterceptor</code>
      java class as follow :</para>

      <programlisting language="java">/*
 * Copyright (c) 2005 Design2see. All rights reserved.
 */
package com.d2s.framework.hrsample.model.service;

import java.util.Date;

import com.d2s.framework.hrsample.model.Traceable;
import com.d2s.framework.model.component.service.EmptyLifecycleInterceptor;
import com.d2s.framework.model.entity.IEntityFactory;
import com.d2s.framework.model.entity.IEntityLifecycleHandler;
import com.d2s.framework.security.UserPrincipal;

/**
 * Default lifecycle service for tracing.
 * &lt;p&gt;
 * Copyright 2005 Design2See. All rights reserved.
 * &lt;p&gt;
 */
public class TraceableLifecycleInterceptor extends
    EmptyLifecycleInterceptor&lt;Traceable&gt; <co id="lcInterceptor" /> {

  /**
   * Sets the create timestamp.
   * &lt;p&gt;
   * {@inheritDoc}
   */
  @Override
  @SuppressWarnings("unused")
  public boolean onPersist(Traceable traceable, IEntityFactory entityFactory,
      UserPrincipal principal, IEntityLifecycleHandler entityLifecycleHandler) {
    traceable.setCreateTimestamp(new Date()); <co id="onPersist" />
    return true; <co id="onPersistReturn" />
  }

  /**
   * Sets the last update timestamp.
   * &lt;p&gt;
   * {@inheritDoc}
   */
  @Override
  @SuppressWarnings("unused")
  public boolean onUpdate(Traceable traceable, IEntityFactory entityFactory,
      UserPrincipal principal, IEntityLifecycleHandler entityLifecycleHandler) {
    traceable.setLastUpdateTimestamp(new Date()); <co id="onUpdate" />
    return true;
  }
}</programlisting>

      <calloutlist>
        <callout arearefs="lcInterceptor">
          <para>The class inherits from the support class
          <code>com.d2s.framework.model.component.service.EmptyLifecycleInterceptor</code>
          which empty implements the required life-cycle interceptor interface
          <code>com.d2s.framework.model.component.service.EmptyLifecycleInterceptor</code>
          as well as the marker interface
          <code>com.d2s.framework.model.component.service.IComponentService</code>.</para>
        </callout>

        <callout arearefs="onPersist">
          <para>Whenever a <code>Traceable</code> component is persisted
          (saved for the first time), set its
          <code>createTimestamp</code>.</para>
        </callout>

        <callout arearefs="onPersistReturn">
          <para>Return true to notify the framework that the state of the
          component has been updated.</para>
        </callout>

        <callout arearefs="onUpdate">
          <para>Whenever a <code>Traceable</code> component is updated
          (subsequent saves), update its
          <code>lastUpdateTimestamp</code>.</para>
        </callout>
      </calloutlist>

      <para>We can now link the life-cycle interceptor to our
      <code>Traceable</code> interface bean descriptor as below :</para>

      <para><programlisting>&lt;bean
  id="Traceable"
  class="com.d2s.framework.model.descriptor.basic.BasicInterfaceDescriptor"&gt;
  ...
  &lt;property name="lifecycleInterceptors"&gt; <co id="lcInterceptors" />
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.hrsample.model.service.TraceableLifecycleInterceptor" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
          <callout arearefs="lcInterceptors">
            <para>Defines an ordered list of life-cycle interceptors attached
            to the component.</para>
          </callout>
        </calloutlist></para>
    </section>

    <section>
      <title>Describing the first entities</title>

      <para>As of now, we have only dealt with interfaces which are not
      entities by themselves. Describing an entity follows the exact same
      process except that we make its descriptor an entity descriptor and that
      we add the <code>com.d2s.framework.model.entity.IEntity</code> standard
      descriptor as one of its ancestors; the latest brings <code>id</code>
      (the entity identifier) and <code>version</code> (used for optimistic
      locking on concurrent access) standard properties.</para>

      <para>So let's describe the <code>City</code> entity as below :</para>

      <programlisting language="xml">&lt;bean
  id="City"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt; <co
          id="BasicEntityDescriptor" />
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.City" /&gt;
  &lt;property name="ancestorDescriptors"&gt; <co id="ancestorDescriptors" />
    &lt;list&gt;
      &lt;ref local="Nameable" /&gt;
      &lt;ref bean="com.d2s.framework.model.entity.IEntity" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="zip" /&gt;
        &lt;property
          name="maxLength"
          value="10" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <calloutlist>
        <callout arearefs="BasicEntityDescriptor">
          <para>Since City is an entity, we use a
          <code>BasicEntityDescriptor</code> which is a special kind of
          component descriptor.</para>
        </callout>

        <callout arearefs="ancestorDescriptors">
          <para>This descriptor inherits from our <code>Nameable</code>
          interface as well as the standard
          <code>com.d2s.framework.model.entity.IEntity</code> descriptor
          bean.</para>
        </callout>
      </calloutlist>

      <para>Relaunching the <trademark>D2S</trademark> generator will produce
      the following class (<filename>City.java</filename>) :</para>

      <programlisting>/*
 * Generated by Design2see. All rights reserved.
 */
package com.d2s.framework.hrsample.model;

/**
 * City entity.
 * &lt;p&gt;
 * Generated by Design2see. All rights reserved.
 * &lt;p&gt;
 *
 * @hibernate.mapping
 *           default-access = "com.d2s.framework.model.persistence.hibernate.property.EntityPropertyAccessor"
 * @hibernate.class
 *   table = "CITY"
 *   dynamic-insert = "true"
 *   dynamic-update = "true"
 *   persister = "com.d2s.framework.model.persistence.hibernate.entity.persister.EntityProxyJoinedSubclassEntityPersister"
 * @author Generated by Design2see
 * @version $LastChangedRevision$
 */
public interface City extends
  com.d2s.framework.hrsample.model.Nameable,
  com.d2s.framework.model.entity.IEntity {

  /**
   * @hibernate.id generator-class = "assigned" column = "ID" type = "string"
   *               length = "36"
   * &lt;p&gt;
   * {@inheritDoc}
   */
  java.io.Serializable getId();

  /**
   * @hibernate.version column = "VERSION" unsaved-value = "null"
   * &lt;p&gt;
   * {@inheritDoc}
   */
  Integer getVersion();

  /**
   * Gets the zip.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "ZIP"
   *           length = "10"
   * @return the zip.
   */
  java.lang.String getZip();

  /**
   * Sets the zip.
   *
   * @param zip
   *          the zip to set.
   */
  void setZip(java.lang.String zip);

}</programlisting>

      <para>You might notice that there are slightly more hibernate xDoclet
      tags (class level tags, id and version) to handle the entity persistence
      specifics. More important is that as for <code>Nameable</code> and
      <code>Traceable</code>, the <code>City</code> entity is not more than an
      interface. This brings to it a fundamental property which is
      multiple-inheritance; and this characteristic is also available among
      entities.</para>
    </section>
  </section>
</chapter>