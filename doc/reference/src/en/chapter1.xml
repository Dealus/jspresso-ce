<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter>
  <title>Getting started</title>

  <para>This chapter will help you to understand the basics of the
  <trademark>D2S</trademark> application framework and how to work with
  it.</para>

  <section>
    <title>The human resources (HR) sample application</title>

    <para>The human resources application is a simple yet comprehensive
    business application targeted at managing a company organization and the
    employees who work in it. It will demonstrate how
    <trademark>D2S</trademark> can handle a domain model with its
    relationships and its constraints, present it to the end-user for
    manipulation through various built-in views and actions, handle security
    through profile management, distribute the frontend across the network,
    ...</para>

    <section>
      <title>The domain model</title>

      <para>To quickly introduce the HR domain model, let's dive into the
      following UML class diagrams. As a general rule to make the diagrams
      more readable attributes must in fact be considered as getter / setter
      pairs.</para>

      <para>The <link linkend="commons-cd">commons class diagram</link>
      describes commonly used interfaces and classes.</para>

      <para>A few hints :</para>

      <itemizedlist>
        <listitem>
          <para>The traceable interface is implemented by entities for which
          we need to record when it was saved for the first time and when it
          was last updated. Of course, these tracing elements must be made
          read-only to the end-user since they are automatically managed by
          the application.</para>
        </listitem>

        <listitem>
          <para>The nameable is implemented by entities having a name. A name
          has a max length of 64 characters and is mandatory.</para>
        </listitem>

        <listitem>
          <para>The contact information component is used by entities that
          have contact details (address, phone, email, ...). A contact
          information points to one and only one city. A city is nameable and
          has a zip code of maximum length 10 characters.</para>
        </listitem>

        <listitem>
          <para>An event is a piece of text which is traceable</para>
        </listitem>
      </itemizedlist>

      <figure id="commons-cd">
        <title>Commons class diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="60%"
                       fileref="../images/commons-cd.png" scalefit="1"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <link linkend="employee-cd">employees class diagram</link>
      describes what an employee is.</para>

      <para>A few hints :</para>

      <itemizedlist>
        <listitem>
          <para>An employee is nameable and traceable. An employee has
          :</para>

          <itemizedlist>
            <listitem>
              <para>a first name (his last name is inherited by the nameable
              interface)</para>
            </listitem>

            <listitem>
              <para>a social security number which is composed by exactly 10
              digits</para>
            </listitem>

            <listitem>
              <para>a gender (male or female)</para>
            </listitem>

            <listitem>
              <para>a birth date</para>
            </listitem>

            <listitem>
              <para>a hire date in the company</para>
            </listitem>

            <listitem>
              <para>a contact information</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>An employee must provide a method to compute his age based on
          his birth date.</para>
        </listitem>

        <listitem>
          <para>An employee has an ordered list of events.</para>
        </listitem>
      </itemizedlist>

      <figure id="employee-cd">
        <title>Employees class diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="60%"
                       fileref="../images/employees-cd.png" scalefit="1"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <link linkend="organization-cd">organization class
      diagram</link> describes how the company is structured in departments
      and teams.</para>

      <para>A few hints :</para>

      <itemizedlist>
        <listitem>
          <para>A company is structured in organizational units. An
          organizational unit may be a department or a team. An organizational
          unit has an identifier (<emphasis>ouId</emphasis>) which is formed
          by a 2 letter code followed by a dash followed by a 3 digit number
          (<emphasis>IS-001</emphasis> for instance). Each organizational unit
          has a manager who is an employee of the company it belongs to. An
          employee can at most manage one organizational unit. An
          organizational unit is nameable, traceable and has contact
          information as well as a company has.</para>
        </listitem>

        <listitem>
          <para>The company may have one or more departments and a department
          belongs to one and only one company.</para>
        </listitem>

        <listitem>
          <para>A department may have one or more teams and a team belongs to
          one and only one department. Each team is composed by one or more
          employees.</para>
        </listitem>

        <listitem>
          <para>An employee belongs to one and only one company. An employee
          may belong to zero or more teams.</para>
        </listitem>
      </itemizedlist>

      <figure id="organization-cd">
        <title>Organization class diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="60%"
                       fileref="../images/organization-cd.png" scalefit="1"
                       width="100%" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>The application modules</title>

      <para>The HR application is divided in 3 modules.</para>

      <section>
        <title>The organization management module</title>

        <para>This module manages a company structure in terms of
        organizational units. The end-user may create/delete/update a company,
        create/delete/update its organizational units and structure them in
        the organization. The end-user may compose the employee teams, assign
        an organisational unit manager but won't be able to
        create/update/delete an employee. The organization must be displayed
        in a hierarchical (tree) view.</para>
      </section>

      <section>
        <title>The employees management module</title>

        <para>This module manages a company staff. The end-user can retrieve
        the company employees and create/update/delete an employee. The
        end-user will be able to create/update/delete events for an employee
        and may re-order them in an unspecified manner as needed.</para>
      </section>

      <section>
        <title>The master data management module</title>

        <para>This module manages the application master data. As of now, the
        master data are only made of the cities available to compose the
        addresses.</para>
      </section>
    </section>

    <section>
      <title>The profiles</title>

      <para>The HR application offers 3 profiles.</para>

      <section>
        <title>The organization manager profile</title>

        <para>A logged-in user having the organization manager profile will be
        granted access to the organization management module as well as the
        master data management module but he won't be able to create a new
        company.</para>
      </section>

      <section>
        <title>The staff manager profile</title>

        <para>A logged-in user having the staff manager profile will be
        granted access to the employee management module as well as the master
        data management module but he won't be able to re-order the events
        assigned to an employee.</para>
      </section>

      <section>
        <title>The administrator profile</title>

        <para>The administrator profile has no restriction in the
        application.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Layering the application</title>

    <para>Now that we have collected the detailed specifications, it's time to
    feed the framework with them. As we saw before, most of the job will
    consist of describing the different layers in a structured way. But before
    going further, let's define the best practices regarding the logical
    layering of a typical <trademark>D2S</trademark> application (although
    these practices may generally apply to any well designed application). We
    will define 3 logical layers from the bottom to the top :</para>

    <itemizedlist>
      <listitem>
        <para>The domain model</para>
      </listitem>

      <listitem>
        <para>The backend</para>
      </listitem>

      <listitem>
        <para>The frontend</para>
      </listitem>
    </itemizedlist>

    <para>This organisation will help to prevent cyclic dependencies between
    layers since each layer will be allowed to use lower ones but not higher
    ones (e.g. : the backend may use the domain model but not the
    frontend).</para>

    <para>Of course, this is a minimal logical layering. Each of this layer
    may be further divided in subparts depending on the software complexity.
    For instance the domain model might be divided in master and movement data
    and the backend and frontend may be divided in modules. It's entirely up
    to the application designer to tailor these rules. But it surely is the
    first design activity.</para>

    <para>The <link linkend="general-cod">general architecture diagram</link>
    introduces this layering strategy.</para>

    <figure id="general-cod">
      <title>General architecture diagram</title>

      <mediaobject>
        <imageobject>
          <imagedata contentdepth="60%" fileref="../images/general-cod.png"
                     scalefit="1" width="100%" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Let's define now what precisely go in these layers.</para>

    <section>
      <title>The domain model</title>

      <para>The domain model includes :</para>

      <itemizedlist>
        <listitem>
          <para>The entities. An entity will be described by :</para>

          <itemizedlist>
            <listitem>
              <para>properties along with their constraints and their
              interceptors</para>
            </listitem>

            <listitem>
              <para>behaviour (business methods, life-cycle
              interceptors)</para>
            </listitem>

            <listitem>
              <para>integrity enforcements</para>
            </listitem>

            <listitem>
              <para>default presentation elements (name, icon, rendered
              properties, ordering properties)</para>
            </listitem>

            <listitem>
              <para>relationships to other entities (cardinality,
              reversibility)</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The components. A component has all the characteristics of an
          entity except that it is not autonomous since It is designed as a
          structure to be inlined in an entity (e.g. : an address
          structure).</para>
        </listitem>

        <listitem>
          <para>Other structural elements like common business
          interfaces.</para>
        </listitem>
      </itemizedlist>

      <para>We will see later that there virtually any domain model can be
      extensively described using <trademark>D2S</trademark>. This includes
      for instance polymorphic entities or associations, multiple inheritance,
      and so on.</para>
    </section>

    <section>
      <title>The backend</title>

      <para>The backend includes all the application parts that do not depend
      on the client :</para>

      <itemizedlist>
        <listitem>
          <para>The actions server parts (which interact with the domain model
          for instance)</para>
        </listitem>

        <listitem>
          <para>The application modules along with their hierarchies of
          sub-modules. A module is a top application entry point which is
          directly accessible by the end user.</para>
        </listitem>

        <listitem>
          <para>The application sub-modules. They form a hierarchy since
          sub-modules may contain other sub-modules. Each sub-module is an
          independent application part targeted at accessing the backend data
          (domain model manipulation, reporting, ...).</para>
        </listitem>

        <listitem>
          <para>The backend controller which holds the user backend
          application state and its configuration (application modules
          registration)</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>The frontend</title>

      <para>The frontend includes all the application parts that interact
      directly with the end-user :</para>

      <itemizedlist>
        <listitem>
          <para>The views</para>
        </listitem>

        <listitem>
          <para>The action client parts (which handle user interaction and
          trigger action server parts)</para>
        </listitem>

        <listitem>
          <para>The client application module parts</para>
        </listitem>

        <listitem>
          <para>The frontend controller which holds the user frontend
          application state and its configuration (client application modules
          registration)</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Describing the domain model</title>

    <para>In this chapter, you will learn how to feed the
    <trademark>D2S</trademark> framework with the hr sample domain model
    description.</para>

    <section>
      <title>Using the Spring dependency injection container</title>

      <para>Let's go back to the HR sample application. As for every layer
      introduced above, describing the domain model will consist in assembling
      <trademark>D2S</trademark> description java beans using the <ulink
      url="http://www.springframework.org/">Spring framework Dependency
      Injection Container</ulink>. To achieve this, you will have to write an
      XML file that conforms to the <ulink
      url="http://www.springframework.org/schema/beans/spring-beans-2.0.xsd">spring
      beans schema</ulink>. Of course, you can use any text editor but we will
      encourage you to use at least a schema-aware XML editor like <ulink
      url="http://www.jedit.org/">jEdit</ulink> or even better, use <ulink
      url="http://www.eclipse.org/">Eclipse</ulink> and <ulink
      url="http://springide.org/project/wiki/SpringideInstall">Spring
      IDE</ulink>. The latest will offer a lot of productivity enhancement
      with code completion for the XML elements and attributes as well as for
      the description bean class names and properties of
      <trademark>D2S</trademark>.</para>

      <para id="chapter1">The various description java beans that are provided
      by <trademark>D2S</trademark> are detailed in the next chapter.</para>

      <para>We will use the root package
      <code>com.d2s.framework.hrsample</code> for our application. The domain
      model description will logically go to the
      <code>com.d2s.framework.hrsample.model</code> package. In this package,
      we will create a <filename>hrsample-model.xml</filename> file as
      described below :</para>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans
  xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
                      http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
  default-lazy-init="true"&gt;

&lt;/beans&gt;</programlisting>
    </section>

    <section>
      <title>Interfaces</title>

      <para>As a starting point, we will describe the <link
      linkend="commons-cd">commons</link> model part.</para>

      <para>The <code>Nameable</code> interface may be described as follow
      :</para>

      <programlisting language="xml">&lt;bean <co id="n-bean" />
  id="Nameable" <co id="n-id" />
  class="com.d2s.framework.model.descriptor.basic.BasicInterfaceDescriptor"&gt; <co
          id="n-class" />
  &lt;constructor-arg
    value="com.d2s.framework.hrsample.model.Nameable" /&gt; <co
          id="n-classname" />
  &lt;property name="propertyDescriptors"&gt; <co id="n-props" />
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;<co
          id="n-stringprop" />
        &lt;property
          name="name" <co id="n-name" />
          value="name" /&gt;
        &lt;property
          name="maxLength" <co id="n-maxl" />
          value="64" /&gt;
        &lt;property
          name="mandatory" <co id="n-mand" />
          value="true" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <calloutlist>
        <callout arearefs="n-bean">
          <para>This is a standard spring bean definition. We are creating a
          descriptor bean.</para>
        </callout>

        <callout arearefs="n-id">
          <para>The identifier of this descriptor bean instance for later
          reference.</para>
        </callout>

        <callout arearefs="n-class">
          <para>Since we are describing a generic interface (which may or may
          not turn to be an entity) we will use a
          <code>BasicInterfaceDescriptor</code> as opposed to a
          <code>BasicEntityDescriptor</code> or
          <code>BasicComponentDescriptor</code>.</para>
        </callout>

        <callout arearefs="n-classname">
          <para>The (fully-qualified) name of this interface.</para>
        </callout>

        <callout arearefs="n-props">
          <para>The property descriptors of this interface descriptor.</para>
        </callout>

        <callout arearefs="n-stringprop">
          <para>The string property descriptor to hold the <code>name</code>
          property description.</para>
        </callout>

        <callout arearefs="n-name">
          <para>The name of the <code>name</code> property which is
          "name".</para>
        </callout>

        <callout arearefs="n-maxl">
          <para>The maximum length of the name property which is 64
          characters.</para>
        </callout>

        <callout arearefs="n-mand">
          <para>The fact that the <code>name</code> property is mandatory on a
          <code>Nameable</code>.</para>
        </callout>
      </calloutlist>

      <para>As you can see above, we create an interface descriptor
      (<code>com.d2s.framework.sample.backend.domain.Nameable</code>) with one
      property (<code>name</code>) along with its constraints
      (<code>maxLength</code> and <code>mandatory</code>). This is a fairly
      simple interface since it has no intrinsic behaviour nor relationships
      with other components.</para>

      <para>So now, lets describe the <code>Traceable</code> interface as
      follow :</para>

      <programlisting language="xml">&lt;bean
  id="Traceable"
  class="com.d2s.framework.model.descriptor.basic.BasicInterfaceDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Traceable" /&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicDatePropertyDescriptor"&gt; <co
          id="t-createTimestamp" />
        &lt;property
          name="name"
          value="createTimestamp" /&gt;
        &lt;property
          name="type"
          ref="DATE_TIME" /&gt; <co id="t-DATE_TIME" />
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicDatePropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="lastUpdateTimestamp" /&gt;
        &lt;property
          name="type"
          ref="DATE_TIME" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="unclonedProperties"&gt; <co id="t-uncloned" />
    &lt;list&gt;
      &lt;value&gt;createTimestamp&lt;/value&gt;
      &lt;value&gt;lastUpdateTimestamp&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <calloutlist>
        <callout arearefs="t-createTimestamp">
          <para>The date property descriptor to hold the
          <code>createTimestamp</code> property. Same applies for the
          <code>lastUpdateTimestamp</code> property.</para>
        </callout>

        <callout arearefs="t-DATE_TIME">
          <para>We want to preserve date and time information in this property
          as opposed to only date information.</para>
        </callout>

        <callout arearefs="t-uncloned">
          <para>Whenever a <code>Traceable</code> component is duplicated, we
          want exclude the tracing values from the cloning process.</para>
        </callout>
      </calloutlist>

      <para>The <code>Traceable</code> interface description is slightly more
      complicated than the <code>Nameable</code> interface since not all
      properties are eligible to cloning
      (<code>unclonedProperties</code>).</para>
    </section>

    <section>
      <title>Generating the code</title>

      <para>It is time now to get our interfaces generated before going
      further. Let's use the <trademark>D2S</trademark> generation tool to
      make it happen. <trademark>D2S</trademark> provides a <ulink
      url="http://freemarker.org/">freemarker</ulink> template to generate the
      components that may be easily triggered using a simple ant task. Since
      this generator explores the spring beans definitions, we first need to
      declare our <code>hrsample-model.xml</code> as being part of our
      application. To achieve that, let's create a configuration file named
      <code>beanRefFactory.xml</code> in the root source folder (without any
      package) as follow :</para>

      <para><programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans
  xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
                      http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
  default-lazy-init="true"&gt;

  &lt;bean
    id="hrsample-model-context"
    class="org.springframework.context.support.ClassPathXmlApplicationContext"
    lazy-init="true"&gt;
    &lt;constructor-arg&gt;
      &lt;list&gt;
        &lt;value&gt;com/d2s/framework/application/commons.xml&lt;/value&gt; <co
            id="brf-commons" />
        &lt;value&gt;com/d2s/framework/tools/entitygenerator/mock.xml&lt;/value&gt; <co
            id="brf-mock" />
        &lt;value&gt;com/d2s/framework/hrsample/model/hrsample-model.xml&lt;/value&gt; <co
            id="brf-model" />
      &lt;/list&gt;
    &lt;/constructor-arg&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</programlisting><calloutlist>
          <callout arearefs="brf-commons">
            <para>The commons bean definitions of the
            <trademark>D2S</trademark> framework.</para>
          </callout>

          <callout arearefs="brf-mock">
            <para>A configuration file to mock undefined (for the moment) bean
            references; this file is only used for the component generation
            phase.</para>
          </callout>

          <callout arearefs="brf-model">
            <para>Our application model description file.</para>
          </callout>
        </calloutlist>This configuration file assembles the necessary spring
      configuration files for the generator to operate. So we are ready to
      operate the generator using the following build.xml ant file :</para>

      <programlisting>&lt;?xml version="1.0"?&gt;

&lt;project default="all"&gt;

  &lt;property file="build.properties" /&gt;
  &lt;property name="xdoclet.lib.dir" value="${xdoclet.home}/lib" /&gt;
  &lt;property name="xdoclet.plugins.dir" value="${xdoclet.home}/plugins" /&gt;

  &lt;property name="src.dir" value="${basedir}/src/main" /&gt;
  &lt;property name="java.src.dir" value="${src.dir}/java" /&gt;
  &lt;property name="resources.src.dir" value="${src.dir}/resources" /&gt;
  &lt;property name="ddl.dir" value="${src.dir}/ddl" /&gt;

  &lt;path id="entity.generator.classpath"&gt;
    &lt;dirset dir="${basedir}"&gt;
      &lt;include name="**/target/classes" /&gt;
    &lt;/dirset&gt;
    &lt;fileset dir="${m2.repo}"&gt;
      &lt;include name="**/design2see/**/2.0/*.jar" /&gt;
      &lt;include name="**/commons-cli-1.0.jar" /&gt;
      &lt;include name="**/freemarker-2.3.3.jar" /&gt;
      &lt;include name="**/spring-2.0.6.jar" /&gt;
      &lt;include name="**/commons-logging-1.1.jar" /&gt;
      &lt;include name="**/xml-apis-2.0.2.jar" /&gt;
      &lt;include name="**/xerces-2.0.2.jar" /&gt;
      &lt;include name="**/bsf-2.3.0.jar" /&gt;
      &lt;include name="**/commons-beanutils-1.7.0.jar" /&gt;
    &lt;/fileset&gt;
  &lt;/path&gt;

  &lt;target name="generate-entities"&gt;
    &lt;java classname="com.d2s.framework.tools.entitygenerator.EntityGenerator"
          classpathref="entity.generator.classpath"&gt;
      &lt;arg value="-applicationContextKey" /&gt;
      &lt;arg value="hrsample-model-context" /&gt;
      &lt;arg value="-templateResourcePath" /&gt;
      &lt;arg value="/com/d2s/framework/tools/entitygenerator" /&gt;
      &lt;arg value="-templateName" /&gt;
      &lt;arg value="HibernateXdocletEntity.ftl" /&gt;
      &lt;arg value="-outputDir" /&gt;
      &lt;arg value="${java.src.dir}" /&gt;
      &lt;arg value="-includePackages" /&gt;
      &lt;arg value="com.d2s.framework.hrsample.model" /&gt;
    &lt;/java&gt;
  &lt;/target&gt;

  &lt;target name="all" depends="generate-entities" /&gt;

&lt;/project&gt;</programlisting>

      <para>You may now have a look into the
      <code>com.d2s.framework.hrsample.model</code> package source directory.
      You may find the 2 generated classes :</para>

      <itemizedlist>
        <listitem>
          <para><filename>Nameable.java</filename> for the Nameable interface
          (see the <link linkend="Nameable">source code below</link>).</para>
        </listitem>

        <listitem>
          <para><filename>Traceable.java</filename> for the Traceable
          interface.</para>
        </listitem>
      </itemizedlist>

      <programlisting id="Nameable" language="java">/*
 * Generated by Design2see. All rights reserved.
 */
package com.d2s.framework.hrsample.model;

/**
 * Nameable component.
 * &lt;p&gt;
 * Generated by Design2see. All rights reserved.
 * &lt;p&gt;
 *
 * @author Generated by Design2see
 * @version $LastChangedRevision$
 */
public interface Nameable {

  /**
   * Gets the name.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "NAME"
   *           length = "64"
   *           not-null = "true"
   * @return the name.
   */
  java.lang.String getName();

  /**
   * Sets the name.
   *
   * @param name
   *          the name to set.
   */
  void setName(java.lang.String name);

}</programlisting>

      <para>These 2 java classes are in fact interfaces with getters and
      setters for the declared properties. In fact, you will never need any
      implementation for them since <trademark>D2S</trademark> will
      automatically handle their implementation for you at runtime using
      proxies. So you might wonder why we still need those interfaces instead
      of completely relying on the descriptors ? This is to benefit from the
      strong compilation enforcements, code completion in IDE, ... Anything
      you will need for quality, robustness and productivity when you are
      manipulating your components.</para>

      <para>You may also notice that the generator took care of annotating the
      classes with <ulink url="http://www.hibernate.org/">hibernate</ulink>
      <ulink
      url="http://xdoclet.sourceforge.net/xdoclet/index.html">xDoclet</ulink>
      attributes. They will be used later to generate the necessary
      persistence meta-data.</para>
    </section>

    <section>
      <title>Adding life-cycle behaviour</title>

      <para>What about the handling of the <code>Traceable</code> properties ?
      We want them to follow the life-cycle of any traceable entity, i.e.
      :</para>

      <itemizedlist>
        <listitem>
          <para>Set the <code>createTimestamp</code> when the entity is
          persisted for the first time.</para>
        </listitem>

        <listitem>
          <para>Set the <code>lastUpdateTimestamp</code> when the entity is
          updated in the persistent store.</para>
        </listitem>
      </itemizedlist>

      <para>It is time to write our first lines of java to achieve that. So
      let's create the life-cycle interceptor
      <code>com.d2s.framework.hrsample.model.service.TraceableLifecycleInterceptor</code>
      java class as follow :</para>

      <programlisting language="java">/*
 * Copyright (c) 2005 Design2see. All rights reserved.
 */
package com.d2s.framework.hrsample.model.service;

import java.util.Date;

import com.d2s.framework.hrsample.model.Traceable;
import com.d2s.framework.model.component.service.EmptyLifecycleInterceptor;
import com.d2s.framework.model.entity.IEntityFactory;
import com.d2s.framework.model.entity.IEntityLifecycleHandler;
import com.d2s.framework.security.UserPrincipal;

/**
 * Default lifecycle service for tracing.
 * &lt;p&gt;
 * Copyright 2005 Design2See. All rights reserved.
 * &lt;p&gt;
 */
public class TraceableLifecycleInterceptor extends
    EmptyLifecycleInterceptor&lt;Traceable&gt; <co id="lcInterceptor" /> {

  /**
   * Sets the create timestamp.
   * &lt;p&gt;
   * {@inheritDoc}
   */
  @Override
  @SuppressWarnings("unused")
  public boolean onPersist(Traceable traceable, IEntityFactory entityFactory,
      UserPrincipal principal, IEntityLifecycleHandler entityLifecycleHandler) {
    traceable.setCreateTimestamp(new Date()); <co id="onPersist" />
    return true; <co id="onPersistReturn" />
  }

  /**
   * Sets the last update timestamp.
   * &lt;p&gt;
   * {@inheritDoc}
   */
  @Override
  @SuppressWarnings("unused")
  public boolean onUpdate(Traceable traceable, IEntityFactory entityFactory,
      UserPrincipal principal, IEntityLifecycleHandler entityLifecycleHandler) {
    traceable.setLastUpdateTimestamp(new Date()); <co id="onUpdate" />
    return true;
  }
}</programlisting>

      <calloutlist>
        <callout arearefs="lcInterceptor">
          <para>The class inherits from the support class
          <code>com.d2s.framework.model.component.service.EmptyLifecycleInterceptor</code>
          which empty implements the required life-cycle interceptor interface
          <code>com.d2s.framework.model.component.service.EmptyLifecycleInterceptor</code>
          as well as the marker interface
          <code>com.d2s.framework.model.component.service.IComponentService</code>.</para>
        </callout>

        <callout arearefs="onPersist">
          <para>Whenever a <code>Traceable</code> component is persisted
          (saved for the first time), set its
          <code>createTimestamp</code>.</para>
        </callout>

        <callout arearefs="onPersistReturn">
          <para>Return true to notify the framework that the state of the
          component has been updated.</para>
        </callout>

        <callout arearefs="onUpdate">
          <para>Whenever a <code>Traceable</code> component is updated
          (subsequent saves), update its
          <code>lastUpdateTimestamp</code>.</para>
        </callout>
      </calloutlist>

      <para>We can now link the life-cycle interceptor to our
      <code>Traceable</code> interface bean descriptor as below :</para>

      <para><programlisting>&lt;bean
  id="Traceable"
  class="com.d2s.framework.model.descriptor.basic.BasicInterfaceDescriptor"&gt;
  ...
  &lt;property name="lifecycleInterceptors"&gt; <co id="lcInterceptors" />
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.hrsample.model.service.TraceableLifecycleInterceptor" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
          <callout arearefs="lcInterceptors">
            <para>Defines an ordered list of life-cycle interceptors attached
            to the component.</para>
          </callout>
        </calloutlist></para>
    </section>

    <section>
      <title>Entities</title>

      <para>As of now, we have only dealt with interfaces which are not
      entities by themselves. Describing an entity follows the exact same
      process except that we make its descriptor an entity descriptor which
      brings <code>id</code> (the entity identifier) and <code>version</code>
      (used for optimistic locking on concurrent access) standard
      properties.</para>

      <para>So let's describe the <code>City</code> entity as below :</para>

      <programlisting language="xml">&lt;bean
  id="City"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt; <co
          id="BasicEntityDescriptor" />
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.City" /&gt;
  &lt;property name="ancestorDescriptors"&gt; <co id="ancestorDescriptors" />
    &lt;list&gt;
      &lt;ref local="Nameable" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="zip" /&gt;
        &lt;property
          name="maxLength"
          value="10" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <calloutlist>
        <callout arearefs="BasicEntityDescriptor">
          <para>Since <code>City</code> is an entity, we use a
          <code>BasicEntityDescriptor</code> which is a special kind of
          component descriptor.</para>
        </callout>

        <callout arearefs="ancestorDescriptors">
          <para>This descriptor inherits from our <code>Nameable</code>
          interface as well as the standard
          <code>com.d2s.framework.model.entity.IEntity</code> descriptor
          bean.</para>
        </callout>
      </calloutlist>

      <para>Relaunching the <trademark>D2S</trademark> generator will produce
      the following class (<filename>City.java</filename>) :</para>

      <programlisting>/*
 * Generated by Design2see. All rights reserved.
 */
package com.d2s.framework.hrsample.model;

/**
 * City entity.
 * &lt;p&gt;
 * Generated by Design2see. All rights reserved.
 * &lt;p&gt;
 *
 * @hibernate.mapping
 *           default-access = "com.d2s.framework.model.persistence.hibernate.property.EntityPropertyAccessor"
 * @hibernate.class
 *   table = "CITY"
 *   dynamic-insert = "true"
 *   dynamic-update = "true"
 *   persister = "com.d2s.framework.model.persistence.hibernate.entity.persister.EntityProxyJoinedSubclassEntityPersister"
 * @author Generated by Design2see
 * @version $LastChangedRevision$
 */
public interface City extends
  com.d2s.framework.hrsample.model.Nameable,
  com.d2s.framework.model.entity.IEntity <co id="IEntity" /> {

  /**
   * @hibernate.id generator-class = "assigned" column = "ID" type = "string"
   *               length = "36"
   * &lt;p&gt;
   * {@inheritDoc}
   */
  java.io.Serializable getId();

  /**
   * @hibernate.version column = "VERSION" unsaved-value = "null"
   * &lt;p&gt;
   * {@inheritDoc}
   */
  Integer getVersion();

  /**
   * Gets the zip.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "ZIP"
   *           length = "10"
   * @return the zip.
   */
  java.lang.String getZip();

  /**
   * Sets the zip.
   *
   * @param zip
   *          the zip to set.
   */
  void setZip(java.lang.String zip);

}</programlisting>

      <calloutlist>
        <callout arearefs="IEntity">
          <para><code>City</code> is an entity so the generator made it
          inherit from <code>com.d2s.framework.model.entity.IEntity</code>
          which is a <trademark>D2S</trademark> framework base class.</para>
        </callout>
      </calloutlist>

      <para>You might notice that there are slightly more hibernate xDoclet
      tags (class level tags, id and version) to handle the entity persistence
      specifics. More important is that as for <code>Nameable</code> and
      <code>Traceable</code>, the <code>City</code> entity is not more than an
      interface. This brings to it a fundamental property which is
      multiple-inheritance; and this characteristic is also available among
      entities.</para>
    </section>

    <section>
      <title>Components</title>

      <para>A component is a data structure which is intended for being
      inlined in other components or entities. Like entities and interfaces,
      you can define properties and behaviour in a component. A component
      cannot live by itself. It is an elegant mean to factor common data and
      behaviour into higher level model parts.</para>

      <para>So let's describe the <code>ContactInfo</code> component as below
      :</para>

      <programlisting language="xml">&lt;bean
  id="ContactInfo"
  class="com.d2s.framework.model.descriptor.basic.BasicComponentDescriptor"&gt; <co
          id="BasicComponentDescriptor" />
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.ContactInfo" /&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="address" /&gt;
        &lt;property
          name="maxLength"
          value="256" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="phone" /&gt;
        &lt;property
          name="maxLength"
          value="32" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="email" /&gt;
        &lt;property
          name="maxLength"
          value="128" /&gt;
        &lt;property
          name="regexpPattern" <co id="regexpPattern" />
          value="[\w\-\.]*@[\w\-\.]*" /&gt;
        &lt;property
          name="regexpPatternSample" <co id="regexpPatternSample" />
          value="contact@acme.com" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <calloutlist>
        <callout arearefs="BasicComponentDescriptor">
          <para>Since <code>ContactInfo</code> is an component, we use a
          <code>BasicComponentDescriptor</code>.</para>
        </callout>

        <callout arearefs="regexpPattern">
          <para>This is a special kind of string constraint enforcement
          through a regular expression; we want an email to conform to contain
          the @ sign, be without space and be only composed of literals plus
          '.' and '-'.</para>
        </callout>

        <callout arearefs="regexpPatternSample">
          <para>Whenever there is some kind of communication to initiate (a
          GUI notification for instance), this is an example of a correct
          value.</para>
        </callout>
      </calloutlist>

      <para>Relaunching the <trademark>D2S</trademark> generator will produce
      the following class (<filename>ContactInfo.java</filename>) :</para>

      <programlisting language="java">/*
 * Generated by Design2see. All rights reserved.
 */
package com.d2s.framework.hrsample.model;

/**
 * ContactInfo component.
 * &lt;p&gt;
 * Generated by Design2see. All rights reserved.
 * &lt;p&gt;
 *
 * @author Generated by Design2see
 * @version $LastChangedRevision$
 */
public interface ContactInfo extends
  com.d2s.framework.model.component.IComponent <co id="IComponent" /> {

  /**
   * Gets the address.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "ADDRESS"
   *           length = "256"
   * @return the address.
   */
  java.lang.String getAddress();

  /**
   * Sets the address.
   *
   * @param address
   *          the address to set.
   */
  void setAddress(java.lang.String address);

  /**
   * Gets the phone.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "PHONE"
   *           length = "32"
   * @return the phone.
   */
  java.lang.String getPhone();

  /**
   * Sets the phone.
   *
   * @param phone
   *          the phone to set.
   */
  void setPhone(java.lang.String phone);

  /**
   * Gets the email.
   *
   * @hibernate.property
   * @hibernate.column
   *           name = "EMAIL"
   *           length = "128"
   * @return the email.
   */
  java.lang.String getEmail();

  /**
   * Sets the email.
   *
   * @param email
   *          the email to set.
   */
  void setEmail(java.lang.String email);

}</programlisting>

      <calloutlist>
        <callout arearefs="IComponent">
          <para><code>ContactInfo</code> is an entity so the generator made it
          inherit from
          <code>com.d2s.framework.model.component.IComponent</code> which is a
          <trademark>D2S</trademark> framework base class.</para>
        </callout>
      </calloutlist>

      <para>You might have notice that the <code>ContactInfo</code> component
      is missing something : its relationship to the <code>City</code>
      entity.</para>
    </section>

    <section>
      <title>Relationships</title>

      <para>It's time to link together our first components together.</para>

      <section>
        <title>N-1 unidirectional</title>

        <para>Let's first deal with the simple unidirectional association
        <code>ContactInfo</code> → <code>City</code>. We are going to define a
        <code>city</code> property in the <code>ContactInfo</code>
        component.</para>

        <para>The following XML fragment will do the trick :</para>

        <programlisting>&lt;bean
  id="ContactInfo"
  class="com.d2s.framework.model.descriptor.basic.BasicComponentDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.ContactInfo" /&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      ...
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor"&gt; <co
            id="BasicReferencePropertyDescriptor" />
        &lt;property
          name="name"
          value="city" /&gt;
        &lt;property
          name="referencedDescriptor"
          ref="City" /&gt; <co id="referencedDescriptor" />
      &lt;/bean&gt;
      ...
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

        <para><calloutlist>
            <callout arearefs="BasicReferencePropertyDescriptor">
              <para><code>ContactInfo</code> has a reference to the
              <code>City</code> entity so we describe this using a
              <code>com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor</code>.</para>
            </callout>

            <callout arearefs="referencedDescriptor">
              <para>We link the reference property descriptor to the
              <code>City</code> entity descriptor we described above (note the
              usage of the <emphasis role="bold">ref</emphasis> spring
              attribute).</para>
            </callout>
          </calloutlist>Relaunching the <trademark>D2S</trademark> generator
        will update the <filename>ContactInfo.java</filename> source file we
        generated above, but since this is a unidirectional relationship, will
        remain the <filename>City.java</filename> file untouched. The
        following lines are added in the <filename>ContactInfo.java</filename>
        source file :</para>

        <para><programlisting>  /**
   * Gets the city.
   *
   * @hibernate.many-to-one
   *           cascade = "persist,merge,save-update,refresh,evict,replicate"
   * @hibernate.column
   *           name = "CITY_ID"
   * @return the city.
   */
  com.d2s.framework.hrsample.model.City getCity();

  /**
   * Sets the city.
   *
   * @param city
   *          the city to set.
   */
  void setCity(com.d2s.framework.hrsample.model.City city);</programlisting>Again,
        the needed hibernate xDoclet tags are added to reflect the
        relationship between the component and the entity.</para>

        <para>To end with the commons model part, let's define the Event
        entity :</para>

        <para><programlisting>&lt;bean
  id="Event"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Event" /&gt;
  &lt;property name="ancestorDescriptors"&gt;
    &lt;list&gt;
      &lt;ref local="Traceable" /&gt; <co id="Traceable" />
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicTextPropertyDescriptor"&gt; <co
              id="BasicTextPropertyDescriptor" />
        &lt;property
          name="name"
          value="text" /&gt;
        &lt;property
          name="maxLength"
          value="2048" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="Traceable">
              <para>An event is a <code>Traceable</code> entity.</para>
            </callout>

            <callout arearefs="BasicTextPropertyDescriptor">
              <para>We use a
              <code>com.d2s.framework.model.descriptor.basic.BasicTextPropertyDescriptor</code>
              instead of a
              <code>com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor</code>.
              This is to inform the framework the this property is likely to
              receive multi-line text; although there is no direct impact on
              the model layer, it might be useful in the view layer (e.g. :
              use a text area instead of a text field to display and edit the
              <code>Event</code> text property).</para>
            </callout>
          </calloutlist>This first relationship is fairly simple since it is a
        n-1 unidirectional association. Of course, the
        <trademark>D2S</trademark> can seamlessly handle 1-n, 1-1 and n-n
        unidirectional and bi-directional associations and compositions
        (strong aggregations).</para>

        <para>Now that we are done with the commons model part, let's see how
        we can handle the employees model part.</para>
      </section>

      <section>
        <title>Inlined components</title>

        <para>The <code>Employee</code> entity is fairly simple to describe
        giving what we already achieved.</para>

        <para>Let's look at the XML fragment below :</para>

        <para><programlisting>&lt;bean
  id="Employee"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Employee" /&gt;
  &lt;property name="ancestorDescriptors"&gt;
    &lt;list&gt;
      &lt;ref local="Nameable" /&gt;
      &lt;ref local="Traceable" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="firstName" /&gt;
        &lt;property
          name="maxLength"
          value="32" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicStringPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="ssn" /&gt;
        &lt;property
          name="maxLength"
          value="10" /&gt;
        &lt;property
          name="regexpPattern"
          value="[\d]{10}" /&gt; <co id="ssn" />
        &lt;property
          name="regexpPatternSample"
          value="0123456789" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicDatePropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="birthDate" /&gt;
        &lt;property
          name="type"
          ref="DATE" /&gt; <co id="birthDate" />
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicDatePropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="hireDate" /&gt;
        &lt;property
          name="type"
          ref="DATE" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicEnumerationPropertyDescriptor"&gt; <co
              id="BasicEnumerationPropertyDescriptor" />
        &lt;property
          name="name"
          value="gender" /&gt;
        &lt;property
          name="enumerationName"
          value="GENDER" /&gt;
        &lt;property
          name="maxLength"
          value="1" /&gt;
        &lt;property
          name="mandatory"
          value="true" /&gt;
        &lt;property name="valuesAndIconImageUrls"&gt; <co
              id="valuesAndIconImageUrls" />
          &lt;map&gt;
            &lt;entry
              key="M"
              value="classpath:images/male-48x48.png" /&gt;
            &lt;entry
              key="F"
              value="classpath:images/female-48x48.png" /&gt;
          &lt;/map&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor"&gt; <co
              id="inlinedComp" />
        &lt;property
          name="name"
          value="contact" /&gt;
        &lt;property
          name="referencedDescriptor"
          ref="ContactInfo" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="ssn">
              <para>We defined a regular expression control on the ssn
              property since it must be composed of 10 and only 10
              digits.</para>
            </callout>

            <callout arearefs="birthDate">
              <para>We don't care about the time information of this date; so
              we use a DATE type as opposed to the DATE_TIME type that we used
              for the <code>Traceable</code> interface.</para>
            </callout>

            <callout arearefs="BasicEnumerationPropertyDescriptor">
              <para>This is a new kind of property descriptor. This one
              defines a finite choice of values for the property.</para>
            </callout>

            <callout arearefs="valuesAndIconImageUrls">
              <para>We define each of the values composing the choice for the
              gender enumeration (either 'M' or 'F') along with icons if
              available.</para>
            </callout>

            <callout arearefs="inlinedComp">
              <para>This is where we reference the <code>ContactInfo</code>
              component.</para>
            </callout>
          </calloutlist>The employee description above shows that it is
        strictly equivalent - as far as description is concerned - to
        reference an entity or to inline a component (see the contact
        reference). The difference will be in the persistence store and in the
        views since an inlined component will have its attributes "merged"
        with the enclosing component as if they belonged to it.</para>
      </section>

      <section>
        <title>1-N unidirectional</title>

        <para>You surely have noticed that we did not describe the 1-N
        composition between <code>Employee</code> and <code>Event</code>. This
        will be our first collection property and since this description will
        be re-used in views (to view and edit the events of an employee), we
        will put it in its own &lt;bean&gt; section so that we can assign it a
        spring id and reference it later :</para>

        <para><programlisting>&lt;bean
  id="Employee-events"
  class="com.d2s.framework.model.descriptor.basic.BasicCollectionPropertyDescriptor"&gt; <co
              id="BasicCollectionPropertyDescriptor" />
  &lt;property
    name="name"
    value="events" /&gt;
  &lt;property
    name="composition"
    value="true" /&gt; <co id="composition" />
  &lt;property name="referencedDescriptor"&gt;
    &lt;bean
      class="com.d2s.framework.model.descriptor.basic.BasicCollectionDescriptor"&gt; <co
              id="BasicCollectionDescriptor" />
      &lt;property
        name="collectionInterface"
        value="java.util.List" /&gt; <co id="collectionInterface" />
      &lt;property
        name="elementDescriptor"
        ref="Event" /&gt; <co id="elementDescriptor" />
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
            <callout arearefs="BasicCollectionPropertyDescriptor">
              <para>We are describing a collection relationship property. This
              is done using a
              <code>com.d2s.framework.model.descriptor.basic.BasicCollectionPropertyDescriptor</code>.</para>
            </callout>

            <callout arearefs="composition">
              <para>We make this relationship a composition to express the
              fact that whenever an employee is deleted, the attached events
              must also be deleted.</para>
            </callout>

            <callout arearefs="BasicCollectionDescriptor">
              <para>A collection property descriptor always references a
              collection descriptor (which may be reused across different
              collection property descriptors)</para>
            </callout>

            <callout arearefs="collectionInterface">
              <para>We need an ordered list of event as specified in the
              analysis; so we use a <code>java.util.List</code> to achieve
              that. We could have used <code>java.util.Set</code> for a set
              semantic (no duplicate and unordered).</para>
            </callout>

            <callout arearefs="elementDescriptor">
              <para>Our collection property lists events; so we reference the
              <code>Event</code> descriptor as being the element type of our
              collection.</para>
            </callout>
          </calloutlist>Then we need to reference the
        <code>Employee-events</code> collection property descriptor in the
        Employee entity. This is done in a single line as shown below :</para>

        <para><programlisting>&lt;bean
  id="Employee"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Employee" /&gt;
  ...
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      ...
      &lt;ref local="Employee-events" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

        <para>As a general rule, you have to remember that each and every bean
        definition in spring can be factored and re-used by making it a
        top-level bean and assigning it an id. This is what we have done for
        the <code>Employee-events</code> descriptor (for later reference but
        not for re-use). All the power of the Spring dependency injection
        container comes into play. For instance, we could easily decide to
        define short (32), medium (128) and long (512) parent string
        descriptors and have all our application string descriptors inherit
        from these. It would make the model more homogeneous and any change a
        matter of an instant. Following this principles, we encourage you to
        make re-usable descriptor bean libraries you can reference among your
        applications. Your descriptor sources will be more concise and more
        readable and maintainable.</para>

        <para>Launching the <trademark>D2S</trademark> generator will generate
        the <filename>Employee.java</filename> source file :</para>

        <para><programlisting>/*
 * Generated by Design2see. All rights reserved.
 */
package com.d2s.framework.hrsample.model;

/**
 * Employee entity.
 * &lt;p&gt;
 * Generated by Design2see. All rights reserved.
 * &lt;p&gt;
 * 
 * @hibernate.mapping default-access =
 *                    "com.d2s.framework.model.persistence.hibernate.property.EntityPropertyAccessor"
 * @hibernate.class table = "EMPLOYEE"
 *   dynamic-insert = "true"
 *   dynamic-update = "true" persister =
 *   "com.d2s.framework.model.persistence.hibernate.entity.persister.EntityProxyJoinedSubclassEntityPersister"
 * @author Generated by Design2see
 * @version $LastChangedRevision$
 */
public interface Employee extends com.d2s.framework.hrsample.model.Nameable,
    com.d2s.framework.hrsample.model.Traceable,
    com.d2s.framework.model.entity.IEntity {

  /**
   * @hibernate.id generator-class = "assigned" column = "ID" type = "string"
   *               length = "36"
   *               &lt;p&gt;
   *               {@inheritDoc}
   */
  java.io.Serializable getId();

  /**
   * @hibernate.version column = "VERSION" unsaved-value = "null"
   *                    &lt;p&gt;
   *                    {@inheritDoc}
   */
  Integer getVersion();

  /**
   * Gets the firstName.
   * 
   * @hibernate.property
   * @hibernate.column name = "FIRST_NAME" length = "32"
   * @return the firstName.
   */
  java.lang.String getFirstName();

  /**
   * Sets the firstName.
   * 
   * @param firstName
   *            the firstName to set.
   */
  void setFirstName(java.lang.String firstName);

  /**
   * Gets the ssn.
   * 
   * @hibernate.property
   * @hibernate.column name = "SSN" length = "10"
   * @return the ssn.
   */
  java.lang.String getSsn();

  /**
   * Sets the ssn.
   * 
   * @param ssn
   *            the ssn to set.
   */
  void setSsn(java.lang.String ssn);

  /**
   * Gets the birthDate.
   * 
   * @hibernate.property type = "date"
   * @hibernate.column name = "BIRTH_DATE"
   * @return the birthDate.
   */
  java.util.Date getBirthDate();

  /**
   * Sets the birthDate.
   * 
   * @param birthDate
   *            the birthDate to set.
   */
  void setBirthDate(java.util.Date birthDate);

  /**
   * Gets the hireDate.
   * 
   * @hibernate.property type = "date"
   * @hibernate.column name = "HIRE_DATE"
   * @return the hireDate.
   */
  java.util.Date getHireDate();

  /**
   * Sets the hireDate.
   * 
   * @param hireDate
   *            the hireDate to set.
   */
  void setHireDate(java.util.Date hireDate);

  /**
   * Gets the gender.
   * 
   * @hibernate.property
   * @hibernate.column name = "GENDER" length = "1" not-null = "true"
   * @return the gender.
   */
  java.lang.String getGender();

  /**
   * Sets the gender.
   * 
   * @param gender
   *            the gender to set.
   */
  void setGender(java.lang.String gender);

  /**
   * Gets the contact.
   * 
   * @hibernate.component prefix = "CONTACT_"
   * @return the contact.
   */
  com.d2s.framework.hrsample.model.ContactInfo getContact();

  /**
   * Sets the contact.
   * 
   * @param contact
   *            the contact to set.
   */
  void setContact(com.d2s.framework.hrsample.model.ContactInfo contact);

  /**
   * Gets the events.
   * 
   * @hibernate.list cascade =
   *                 "persist,merge,save-update,refresh,evict,replicate,delete"
   * @hibernate.key column = "EVENTS_PARENT_ID"
   * @hibernate.one-to-many class = "com.d2s.framework.hrsample.model.Event"
   * @hibernate.list-index column = "EVENTS_SEQ"
   * @return the events.
   */
  java.util.List&lt;com.d2s.framework.hrsample.model.Event&gt; getEvents();

  /**
   * Sets the events.
   * 
   * @param events
   *            the events to set.
   */
  void setEvents(java.util.List&lt;com.d2s.framework.hrsample.model.Event&gt; events);

  /**
   * Adds an element to the events.
   * 
   * @param eventsElement
   *            the events element to add.
   */
  void addToEvents(com.d2s.framework.hrsample.model.Event eventsElement);

  /**
   * Adds an element to the events at the specified index. If the index is out
   * of the list bounds, the element is simply added at the end of the list.
   * 
   * @param index
   *            the index to add the events element at.
   * @param eventsElement
   *            the events element to add.
   */
  void addToEvents(int index,
      com.d2s.framework.hrsample.model.Event eventsElement);

  /**
   * Removes an element from the events.
   * 
   * @param eventsElement
   *            the events element to remove.
   */
  void removeFromEvents(com.d2s.framework.hrsample.model.Event eventsElement);

}</programlisting>As you can see above, the generator has generated all the
        accessors for the events list property. If the events property had
        been designed as a set instead of a list, the adder using the index
        would not have been generated and the get/set pair would of course
        have used a <code>java.util.Set</code> instead of a
        <code>java.util.List</code>.</para>

        <para>Now that the employees model part is complete, let's deal with
        the organization.</para>
      </section>
    </section>

    <section>
      <title>Entity inheritance</title>

      <para>The organization model part is the most complex of the example,
      since it involves entity inheritance (and polymorphism) and other kinds
      of relationships (1-1, bi-directional). So let's begin with the entity
      inheritance graph and we will deal with their relationships next.</para>

      <para><programlisting>&lt;bean
  id="Company"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Company" /&gt;
  &lt;property name="ancestorDescriptors"&gt;
    &lt;list&gt;
      &lt;ref local="Nameable" /&gt;
      &lt;ref local="Traceable" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="contact" /&gt;
        &lt;property
          name="referencedDescriptor"
          ref="ContactInfo" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean
  id="OrganizationalUnit"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.OrganizationalUnit" /&gt;
  &lt;property name="purelyAbstract" value="true" /&gt; <co
            id="purelyAbstract" />
  &lt;property name="ancestorDescriptors"&gt;
    &lt;list&gt;
      &lt;ref local="Nameable" /&gt;
      &lt;ref local="Traceable" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="propertyDescriptors"&gt;
    &lt;list&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicTextPropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="ouId" /&gt;
        &lt;property
          name="regexpPattern"
          value="[A-Z]{2}-[\d]{3}" /&gt;
        &lt;property
          name="regexpPatternSample"
          value="IS-123" /&gt;
        &lt;property
          name="maxLength"
          value="6" /&gt;
      &lt;/bean&gt;
      &lt;bean
        class="com.d2s.framework.model.descriptor.basic.BasicReferencePropertyDescriptor"&gt;
        &lt;property
          name="name"
          value="contact" /&gt;
        &lt;property
          name="referencedDescriptor"
          ref="ContactInfo" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean
  id="Department"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Department" /&gt;
  &lt;property name="ancestorDescriptors"&gt;
    &lt;list&gt;
      &lt;ref local="OrganizationalUnit" /&gt; <co id="OrganizationalUnit" />
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean
  id="Team"
  class="com.d2s.framework.model.descriptor.entity.basic.BasicEntityDescriptor"&gt;
  &lt;constructor-arg value="com.d2s.framework.hrsample.model.Team" /&gt;
  &lt;property name="ancestorDescriptors"&gt;
    &lt;list&gt;
      &lt;ref local="OrganizationalUnit" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting><calloutlist>
          <callout arearefs="purelyAbstract">
            <para>An <code>OrganizationalUnit</code> will never be
            instantiated as such; only sub-entities will. This is why we
            define the entity as purely abstract.</para>
          </callout>

          <callout arearefs="OrganizationalUnit">
            <para><code>Department</code> inherits from
            <code>OrganizationalUnit</code> as do <code>Team</code>.</para>
          </callout>
        </calloutlist>Pretty easy, no ? You describe entity inheritance
      exactly as you did previously for the interfaces. You don't have to care
      for anything else, the framework will handle it behind the scene for
      you.</para>

      <para>You can see also that <code>Company</code>,
      <code>OrganizationalUnit</code>, and <code>Employee</code> have the same
      contact property as an inlined <code>ContactInfo</code> component. It is
      a perfect candidate for factoring. So we can make the contact property
      descriptor a top level bean and reference it in the 3 entities above.
      The result will be :</para>
    </section>

    <section>
      <title>Bi-directional 1-N relationships</title>

      <para></para>
    </section>
  </section>
</chapter>